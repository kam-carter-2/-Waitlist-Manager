 # waitlist_manager.py

# -----------------------------
# Node Class
# -----------------------------
class Node:
    def __init__(self, name):
        self.name = name
        self.next = None


# -----------------------------
# LinkedList Class
# -----------------------------
class LinkedList:
    def __init__(self):
        self.head = None

    def add_front(self, name):
        new_node = Node(name)
        new_node.next = self.head
        self.head = new_node

    def add_end(self, name):
        new_node = Node(name)
        if not self.head:
            self.head = new_node
            return f"{name} added to the end of the waitlist"
        current = self.head
        while current.next:
            current = current.next
        current.next = new_node
        return f"{name} added to the end of the waitlist"

    def remove(self, name):
        if not self.head:
            return f"{name} not found"

        # if head matches
        if self.head.name == name:
            self.head = self.head.next
            return f"Removed {name} from the waitlist"

        prev = self.head
        current = self.head.next
        while current:
            if current.name == name:
                prev.next = current.next
                return f"Removed {name} from the waitlist"
            prev = current
            current = current.next
        return f"{name} not found"

    def print_list(self):
        if not self.head:
            print("The waitlist is empty")
            return
        print("Current waitlist:")
        current = self.head
        while current:
            print(f"- {current.name}")
            current = current.next


# -----------------------------
# User Input CLI
# -----------------------------
def waitlist_generator():
    waitlist = LinkedList()

    while True:
        print("\n--- Waitlist Manager ---")
        print("1. Add customer to front")
        print("2. Add customer to end")
        print("3. Remove customer by name")
        print("4. Print waitlist")
        print("5. Exit")

        choice = input("Choose an option (1–5): ")

        if choice == "1":
            name = input("Enter customer name to add to front: ")
            waitlist.add_front(name)
        elif choice == "2":
            name = input("Enter customer name to add to end: ")
            print(waitlist.add_end(name))
        elif choice == "3":
            name = input("Enter customer name to remove: ")
            print(waitlist.remove(name))
        elif choice == "4":
            waitlist.print_list()
        elif choice == "5":
            print("Exiting waitlist manager.")
            break
        else:
            print("Invalid choice. Please enter a number from 1 to 5.")


# -----------------------------
# Run Program
# -----------------------------
if __name__ == "__main__":
    waitlist_generator()


# -----------------------------
# Design Memo (200–300 words)
# -----------------------------
"""
Our waitlist manager uses a linked list to store customer names in order. Each customer
is represented as a Node, which contains the customer’s name and a pointer to the next
Node. The LinkedList class keeps track of the first Node with the head attribute. This
structure allows efficient insertion at the front of the list, since we only need to update
the head pointer.

The head plays a crucial role, acting as the entry point to the entire list. If we lose the
head, we lose access to the entire waitlist. By adjusting the head pointer and the next
pointers of nodes, we can add customers to the front or end and remove them by name.
The program’s methods handle these operations while keeping the order of the waitlist
intact.

In real-world software, engineers may use a custom linked list when working with data
streams, queues, or systems where performance for insertion/deletion matters more than
random access. For example, an operating system may use linked lists for scheduling
processes, or a customer service application could use them to manage dynamic waitlists
without needing to shift array elements. This project shows how linked lists give
flexibility and control compared to built-in Python lists, and why understanding data
structures is important for scalable software design.
"""
